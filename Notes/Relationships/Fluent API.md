# When things get COMPLEX

The beauty of Entity Framework is that it employs a convention-over-configuration paradigm, which means that it makes intelligent guesses based on the structure of your model classes, and it will often create these relationships automatically when a migration is generated.
The Fluent API configurations are essentially a way of overriding these conventions when you need to. For example, if you want to use a non-convention name for your foreign key, or specify deletion behavior, you would need to use Fluent API.
However, it is recommended to use Fluent API configurations with complex relationships or where explicit configuration is preferred over default conventions. It makes the relationships in the model clearer to anyone reading the code. Moreover, Fluent API provides more functionality compared to Data Annotations. It provides configurations for many-to-many relationships, one-to-one relationships, property types, etc., which are not achievable through Data Annotations.

## Where to define the Fluent API configurations

This should be done in the `DbContext` class. The Entity Framework Core DbContext acts as a bridge between your domain/entity classes and the database. It's where you can specify how your entities relate to one another and how they map to the database schema. 

```csharp
public class MyDbContext : DbContext
{
    public DbSet<Character> Characters { get; set; }
    public DbSet<Weapon> Weapons { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Weapon>()
            .HasOne(w => w.Character)
            .WithOne(c => c.Weapon)
            .HasForeignKey<Weapon>(w => w.CharacterId)
            .HasConstraintName("FK_Weapon_Character"); // Set custom FK name
    }
}
```

In the OnModelCreating method, we can use the Fluent API to configure our Entity Framework model. This will affect the database schema generated by Migrations and/or Database.EnsureCreated().
When you add a new migration, Entity Framework Core will look at your DbContext and generate the appropriate SQL to update the database schema to match your model configuration.


## When projects get big
There is a best practice to follow to make Fluent API configurations more maintainable. You can use the IEntityTypeConfiguration interface to configure each entity in a separate class. This way, you can keep each configuration isolated and easy to manage. Here is an example: 

```csharp
public class WeaponConfiguration : IEntityTypeConfiguration<Weapon>
{
    public void Configure(EntityTypeBuilder<Weapon> builder)
    {
        builder
            .HasOne(w => w.Character)
            .WithOne(c => c.Weapon)
            .HasForeignKey<Weapon>(w => w.CharacterId)
            .HasConstraintName("FK_Weapon_Character"); 
        // You can add more configurations for Weapon entity here
    }
}
```

You can create a separate configuration class for each of your entities. Then in your DbContext class, you apply these configurations in the OnModelCreating method like this:

```csharp
public class MyDbContext : DbContext
{
    public DbSet<Character> Characters { get; set; }
    public DbSet<Weapon> Weapons { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfiguration(new WeaponConfiguration());
        // Apply other configurations...
    }
}
```

We can take this a further when using IEntityTypeConfiguration<T>, instead of instantiating the configuration class manually in OnModelCreating method, you can use the ApplyConfigurationsFromAssembly method. This method applies all configuration classes that are defined in the assembly of a given type.
This way, you won't have to remember to add each new configuration class to your DbContext. Here's how you can do it:

```csharp
public class MyDbContext : DbContext
{
    public DbSet<Character> Characters { get; set; }
    public DbSet<Weapon> Weapons { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(MyDbContext).Assembly);
    }
}
```

Here's what's going on here:
An assembly in .NET is a compiled unit of code, such as a DLL or EXE file. It contains one or more types (classes, interfaces, enums, etc.).
Entity Framework Core's `ApplyConfigurationsFromAssembly` method is a way of telling the DbContext to scan the assembly (DLL) that contains a given type for any classes that implement the `IEntityTypeConfiguration<T>` interface, and apply those configurations to the model being built.
So, when you use ApplyConfigurationsFromAssembly(typeof(MyDbContext).Assembly) in the OnModelCreating method, EF Core is instructed to:
1. Look at the assembly (DLL) that contains the `MyDbContext` class.
2. Find all classes in that assembly that implement `IEntityTypeConfiguration<T>`.
3. Instantiate each of those classes and call the Configure method to apply the corresponding configuration to the model being built.
   (`Configure` method is coming from `IEntityTypeConfiguration<T> interface`, you implement this)

This is incredibly useful because it means you don't have to manually register every single `IEntityTypeConfiguration<T>` implementation in your OnModelCreating method. As you add more entities and corresponding configurations to your model, this can save you a lot of time and make your code more maintainable.