# Defining `One-to-One`

When defining `One-to-one` relationships it is important to consider what is the **dependent** part of the relationship and
what is the **principal** entity. 

To define a `One-to-One` between `Character` and `Weapon`, where `Character` is the principal and `Weapon` is the dependent
we would do the following:
- What this means is that a `Character` could exist without a `Weapon` but a `Weapon` can't exist without being associated with a `Character`.
(_With this particular setup (the `Character` being the principal and `Weapon` being the dependent), a `Weapon` cannot exist without being associated with a Character due to **referential integrity**. However, a `Character` may exist without a `Weapon` because the relationship is optional (a nullable `Weapon` navigation property in `Character`)._)

```csharp
public class Character
{
    public int Id { get; set; }

    // ...other properties...

    public Weapon Weapon { get; set; } // This is a navigation property to Weapon
}

public class Weapon
{
    public int Id { get; set; }

    // ...other properties...

    public int CharacterId { get; set; } // this is what define the "dependent" part of the relationship (the foreign key). Class name ("Character") followed by "Id" is a convention and entity framework knows that this is the corresponding foreign key for the "Character" property

    public Character Character { get; set; }
}
```
Remember to add the new entity into `DataContext` and run the migration to create the relationship and the new table (`Weapons`).

The Fluent API configuration for the above relationship is as follows:
```csharp
modelBuilder.Entity<Weapon>()
    .HasOne(w => w.Character)
    .WithOne(c => c.Weapon)
    .HasForeignKey<Weapon>(w => w.CharacterId);
```

You don't have to write this as it will be auto-generated by the Entity Framework when the migration is generated. However, if you need to make any changes that are outside the conventions consider
using the Fluent Api Configurations. You will be able to find this auto generated in the migrations design file

## Having `Id's` in both entities is BAD! 

Consider the following scenario:

```csharp
public class Character
{
    // ... existing properties ...

    public int? WeaponId { get; set; }
    
    public Weapon? Weapon { get; set; }
}

public class Weapon
{
    public int Id { get; set; }

    public string Name { get; set; }

    public int Damage { get; set; }
    
    public int CharacterId { get; set; }
    
    public Character Character { get; set; }
}
```

This is what is known as a circular dependency which is a bad database design. Some of the reasons why it's bad are:

- Integrity Constraints: Adding, updating, or deleting data in circular references can be a major issue due to foreign key constraints. A record in Table A may reference a record in Table B, which in turn references the record in Table A. Now if you want to insert data into these tables, you'll encounter a Catch-22 situation where you can't insert into Table A before Table B because A needs data from B and vice-versa.
- Cascade Delete Risks: In a circular dependency, if you have cascading deletes turned on, deleting a single record can potentially wipe out vast amounts of data if not handled cautiously. Unnecessary data loss could happen.
- Poor Performance: Some database operations like table joins and recursive queries can be slower due to the increased complexity of resolving the circular relationships.
- Complicates the Application Logic: The presence of circular dependencies might lead to redundancies in data. It also makes your application's persistence layer more complex, as you have to constantly make sure the data is consistent in all interdependent entities.


## A note on the nullable reference type `?`
When you have `public Weapon? Weapon { get; set; }`, it means that `Weapon` property in `Character` class can be null, and the compiler won't warn you about possible NullReferenceExceptions when you're accessing these properties.
But this doesn't affect on how Entity Framework Core interprets the relationships. EF Core determines relationships based on the presence of navigation and foreign key properties.
