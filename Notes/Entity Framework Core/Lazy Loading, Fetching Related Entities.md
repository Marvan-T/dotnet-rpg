# Fetching related entities

By default the entity framework core does not related entities in a realtionship. Here's an example,

```csharp
var character = await _context.Characters.FirstOrDefaultAsync(c => c.Id == updatedCharacter.Id);

character.User //this is `null`
```
To fetch the related entity `User` from the `Character` object we have to explicitly ask for the `User` when retrieivng the 
`Character`. 

```csharp
var character = await _context.Characters
    .Include(c => c.User)
    .FirstOrDefaultAsync(c => c.Id == id);
```

## Other ways of fetching related entities 

`Include` and `ThenInclude` are the most common approaches for loading related entities. We use `ThenInclude()` when we 
want to retrieve a property of a property , i.e., a second level property and beyond. For example, if User has a navigation property Address, and you want to load it too:
```csharp
var character = await _context.Characters
    .Include(c => c.User)
        .ThenInclude(u => u.Address)
    .FirstOrDefaultAsync(c => c.Id == id);
```

**There are few more approaches that are useful in specific scenarios**
- `Load()`: This is used for explicit loading. This is not like eager loading (using Include) or lazy loading. With explicit loading, the related entities are loaded from the database at a time later than when the principal entity was loaded.
    - The 'principal entity/main entity' is initially queried and loaded into memory without any of its related entities. These related entities are retrieved in a separate query at a later time.
```csharp
var character = await _context.Characters.FindAsync(characterId); //character is loaded first

// later in the code
context.Entry(character).Reference(c => c.User).Load(); // User is loaded later through as a seperate query
```
- `Projections`: It **includes related data as part of the query** and can be an efficient way in some scenarios. But with projections, the related data isn't tracked for any changes.
  (_like selecting only the columns we need in a SQL query, in EF core there is more flexibility to shape it_)
- Use of `AsNoTracking()`: This method returns a new query where the change tracker will not track any of the entities that are returned. If the entities being returned are not meant to be updated in the context, using AsNoTracking can give you some performance benefits.
  (_the performance gains in `AsNoTracking()` mostly because the entities returned are not stored in the DbContext for change tracking. This can save a lot of memory when querying large numbers of entities._)
```csharp
var character = await _context.Characters.AsNoTracking()
    .Include(c => c.User)
    .FirstOrDefaultAsync(c => c.Id == id);
```


## A bit more on `Projections`

In Entity Framework, projection involves transforming the results of a query into a different form. This often occurs by specifying the properties we're interested in within the Select clause of the query. Specifically, projection becomes useful when we want to select a subset of data or related data in a custom structure.
For example, instead of using Include():

```csharp
var characterWithUser = await _context.Characters
    .Include(c => c.User)
    .FirstOrDefaultAsync(c => c.Id == id);
```

You can use projections to select both Character and User in a custom way:

```csharp
var characterWithUser = await _context.Characters
    .Where(c => c.Id == id)
    .Select(c => new 
    { 
        CharacterDetails = c, 
        UserDetails = c.User
    })
    .FirstOrDefaultAsync();
```

The projection example yields a data structure containing both the `Character` details and the corresponding User details.
- However, the main difference is that in the Include example, changes to the `User` will be tracked by Entity Framework's change tracking mechanism, so Entity Framework will be aware of any changes made to User and will reflect these in the database when `SaveChanges()` is called. In contrast, with the projection example, the `UserDetails` attribute is not tracked. This means that even if you make any changes to `UserDetails`, Entity Framework won’t know about that change and it won't be reflected in the database when `SaveChanges()` is called.
- Regarding the number of queries with `Include()`, Entity Framework Core tries to optimize these operations by generating a single SQL query behind the scenes whenever it can, so the `Include()` method doesn't necessarily mean two separate queries are being executed. However, depending on the complexity, sometimes it might opt to split the queries (like for many-to-many relationships). You can always check the actual SQL queries being generated by enabling the Entity Framework Core logging.

Projections can offer more efficient querying by getting only what is needed rather than getting full entities. However, it also means you need to work with EF tracking limitations and can be a bit more complex to setup for complex relationships as compared to `Include()`.


## Lazy loading vs not fetching related entities 

The end results of these look similar but they mean different things.
- When we talk about not fetching related entities by default, it means that when you fetch a `Character` entity from your database using Entity Framework Core, the related `User` entity won't be included in the result unless you explicitly use the `Include()` method.
- When it comes to lazy loading, however, things work a bit differently. If lazy loading is enabled, the related `User` entity will still not be included initially when you fetch a `Character`. The difference comes when you try to access the `User` property on the fetched `Character` - if lazy loading is enabled, Entity Framework will automatically fetch the `User` from the database **just-in-time** when you try to access the `User` property.

By default, Entity Framework Core does not support this just-in-time fetching, i.e., lazy loading isn't enabled by default. You'll need to enable it explicitly by installing the `Microsoft.EntityFrameworkCore.Proxies` package and modifying your DbContext configuration.